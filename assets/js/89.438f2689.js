(window.webpackJsonp=window.webpackJsonp||[]).push([[89],{551:function(v,e,_){"use strict";_.r(e);var o=_(2),c=Object(o.a)({},(function(){var v=this,e=v._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[e("h1",{attrs:{id:"vue2及vue3响应式原理理解"}},[e("code",[v._v("vue2")]),v._v("及"),e("code",[v._v("vue3")]),v._v("响应式原理理解")]),v._v(" "),e("p",[v._v("响应式数据的核心就是数据变化能被知道，对象在"),e("code",[v._v("vue2")]),v._v("中使用了"),e("code",[v._v("defineProperty")]),v._v("将数据定义成响应式数据（拦截了所有的）")]),v._v(" "),e("ol",[e("li",[v._v("所谓数据响应式就是能够使数据变化可以被检测并对这种变化做出响应的机制。")]),v._v(" "),e("li",[e("code",[v._v("MVVM")]),v._v("框架中要解决的一个核心问题是连接数据层和视图层，通过数据驱动应用，数据变化，视图更新，要做\n到这点的就需要对数据做响应式处理，这样一旦数据发生变化就可以立即做出更新处理。")]),v._v(" "),e("li",[v._v("以"),e("code",[v._v("vue")]),v._v("为例说明，通过数据响应式加上虚拟"),e("code",[v._v("DOM")]),v._v("和"),e("code",[v._v("patch")]),v._v("算法，开发人员只需要操作数据，关心业务，完全不\n用接触繁琐的"),e("code",[v._v("DOM")]),v._v("操作，从而大大提升开发效率，降低开发难度。")]),v._v(" "),e("li",[e("code",[v._v("vue2")]),v._v("中的数据响应式会根据数据类型来做不同处理，如果是对象则采用"),e("code",[v._v("ObjectdefineProperty()")]),v._v("的方式定义数据拦截，当数据被访问或发生变化时，我们感知并作出响应;如果是数组则通过覆盖数组对象原型的7个变更方法，使这些方法可以额外的做更新通知，从而作出响应。这种机制很好的解决了数据响应化的问题，但在实际使用中也存在一些缺点:比如初始化时的递归遍历会造成性能损失;新增或删除属性时需要用户使用 "),e("code",[v._v("Vue set/delete")]),v._v("这样特殊的"),e("code",[v._v("api")]),v._v("才能生效;对于"),e("code",[v._v("es6")]),v._v("中新产生的"),e("code",[v._v("Map/Set")]),v._v("这些数据结构不支持等问题。")]),v._v(" "),e("li",[v._v("为了解决这些问题，"),e("code",[v._v("vue3")]),v._v("重新编写了这一部分的实现:利用"),e("code",[v._v("ES6")]),v._v("的"),e("code",[v._v("Proxy")]),v._v("代理要响应化的数据，它有很多好\n处，编程体验是一致的，不需要使用特殊"),e("code",[v._v("api")]),v._v("，初始化性能和内存消耗都得到了大幅改善;另外由于响应化的\n实现代码抽取为独立的"),e("code",[v._v("reactivity")]),v._v("包，使得我们可以更灵活的使用它，第三方的扩展开发起来更加灵活了。")])])])}),[],!1,null,null,null);e.default=c.exports}}]);